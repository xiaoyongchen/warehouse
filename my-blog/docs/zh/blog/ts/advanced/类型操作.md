# TS ç±»å‹æ“ä½œ 
## ä¾èµ–ç±»å‹åˆ›å»ºç±»å‹
---

## infer
- èƒŒæ™¯
  
- ä¾‹å­
  ```typescript
    type getTypeWityAny<T> = T extends infer R ? R : never;
    type Str = GetTypeWityAny<string>; // string
    type Bo = GetTypeWityAny<boolean>; // boolean
    type Na = GetTypeWityAny<typeof NaN>; // number

    // ä¾‹2 NonNullableå®ç°
    type NonNullable<T extends unknown> = T extends null | undefined ? never : T;

    // ä¾‹3 ReturnTypeå®ç°
    type ReturnType<T> = T extends (...arg: []) => infer R ? R : any;
  ```
- æ€»ç»“
  <br>tips: ç±»ä¼¼ä¸€ä¸ªèŒƒå‹å‚æ•°çš„å ä½ç¬¦(ç±»ä¼¼placeHolder), ä¸€èˆ¬æ­é…extendså’ŒèŒƒå‹ä½¿ç”¨; 

  ## const
- èƒŒæ™¯
  
- ä¾‹å­
  ```typescript
    // å˜é‡
    let a = 123 as const;
    a = 1; // Cannot assign to 'a' because it is a constant.(2588)

    // æ•°ç»„ popï¼Œ shiftï¼Œunshift, map, filter, some, every, find, findIndex ç­‰
    let arr = [1,2,3] as const;
    a.pop(); // Property 'pop' does not exist on type 'readonly [1, 2, 3]'.(2339)
  ```
- æ€»ç»“
  <br>tips:as const ç±»ä¼¼è®¾ç½®Readonly å¼ºåˆ¶å›ºå®šå®šä¹‰çš„ç±»å‹; 
  * ReadonlyåŒºåˆ«
  
    + const ç”¨äºå˜é‡ï¼Œ readonly ç”¨äºå±æ€§
    + const åœ¨è¿è¡Œæ—¶æ£€æŸ¥ï¼Œ readonly åœ¨ç¼–è¯‘æ—¶æ£€æŸ¥
    + const å£°æ˜çš„å˜é‡ä¸å¾—æ”¹å˜å€¼ï¼Œè¿™æ„å‘³ç€ï¼Œconst ä¸€æ—¦å£°æ˜å˜é‡ï¼Œå°±å¿…é¡»ç«‹å³åˆå§‹åŒ–ï¼Œä¸èƒ½ç•™åˆ°ä»¥åèµ‹å€¼; readonly ä¿®é¥°çš„å±æ€§èƒ½ç¡®ä¿è‡ªèº«ä¸èƒ½ä¿®æ”¹å±æ€§ï¼Œä½†æ˜¯å½“ä½ æŠŠè¿™ä¸ªå±æ€§äº¤ç»™å…¶å®ƒå¹¶æ²¡æœ‰è¿™ç§ä¿è¯çš„ä½¿ç”¨è€…(å…è®¸å‡ºäºç±»å‹å…¼å®¹æ€§çš„åŸå› )ï¼Œä»–ä»¬èƒ½æ”¹å˜<br>
  
## Conditional (SomeType extends OtherType ? TrueType : FalseType;)
- ä¾‹å­
  ```typescript
    // é…åˆæ¡ä»¶åˆ¤æ–­ä½¿ç”¨ï¼Œå¯ä»¥çœ‹ä½œtsçš„3ç›®è¿ç®—
    type isBoolean<T> = T extends boolean ? 'æ¡ä»¶æˆç«‹' : 'æ¡ä»¶ä¸æˆç«‹';
    type Res = isBoolean<true>; // æ¡ä»¶æˆç«‹ 

    // åˆ†é…å¼æ¡ä»¶ç¼–è¯‘
    type DistributiveType<T> = T extends infer R ? R[] : never;
    type Distributive = DistributiveType<number | string>;  // number[] : string[]
  ```
- æ€»ç»“
  <br>tips: å¯ä»¥çœ‹ä½œåŒ…å«äºï¼Œæ¯”å¦‚1 <= 2;

## keyof

- ä¾‹å­
  ```typescript
    // object
    type Obj = {index: number; func: () => void; sym: Symbol; };
    type value = keyof Obj; // keyof Obj

    // æ•°ç»„
    type Arr = { [n: number]: unknow }; // [number] | number[];
    type value = keyof Arr;  // number

    // å…ƒç»„
    type Arr = {[n: number]: number | boolean };
    type key = keyof Arr;
    const a: Arr = [false, 1];
  ```
- æ€»ç»“
  <br> tips: å¾—åˆ°ä¸€ä¸ªè”åˆç±»å‹

  ## typeof

- ä¾‹å­
  ```typescript
    // å˜é‡çš„è¯ï¼Œconst vs let æœ‰åŒºåˆ«ã€‚const æœ‰ç±»å‹æ”¶çª„
    const a = '1';
    type A = typeof a;  // '1'
    let b = '1';
    type B = type b; // string

    // å¯¹è±¡é‡Œé¢éƒ½æ˜¯let ä¿®é¥°çš„ã€‚
    const obj = { index: 1, func: () => {}, sym: Symbol() };
    type Obj = typeof obj;  // { index: number; func: () => void; sym: symbol }

    const arr = [1,2,3,4];
    type Arr = typeof arr;  // number[]
  ```
- æ€»ç»“
  <br> tips: æ³¨æ„å˜é‡å’Œå¯¹è±¡constäºletåŒºåˆ«

## Indexed

- ä¾‹å­
  ```typescript
    // å¯¹è±¡,ä¸€ä¸€å¯¹åº”
    type Person = { age: number; name: string; alive: boolean };
    type Age = Person["age"]; // number
    type AgeOrName = Person['age' | 'name']; // number | name
    type keys = Person[keyof Person];// === Person['age' | 'name' | 'alive']


    // å¯¹è±¡é‡Œé¢éƒ½æ˜¯let ä¿®é¥°çš„ã€‚
    const obj = { index: 1, func: () => {}, sym: Symbol() };
    type Obj = typeof obj;  // { index: number; func: () => void; sym: symbol }

    const arr = [1,2,3,4];
    type Arr = typeof arr;  // number[]
  ```
- æ€»ç»“
  <br> tips: å¯ä»¥çœ‹ä½œå–å±æ€§çš„ç±»å‹å£°æ˜

## Mapped æ˜ å°„

- ä¾‹å­
  ```typescript
    // ä¿®æ”¹åŸæœ‰çš„å±æ€§å€¼
    type ObjFunc = {
      func: () => void;
      func1: () => boolean;
    }

    type ObjBoolean<T> = {
      [key in keyof T]: boolean;
    }

    type NewObjFunc = ObjBoolean<ObjFunc>;  // { func: boolean; func1: boolean }

    // ä¿®æ”¹åŸæœ‰ç±»å‹å˜é‡å¯è¯»å±æ€§,æ–°å¢å¯è¯»æ€§å±æ€§
    type ObjFunc = {
      readonly func: () => void;
      readonly func1: () => boolean;
    }

    type ObjBoolean<T> = {
      -readonly [key in keyof T] +?: boolean;
    }

    type NewObjFunc = ObjBoolean<ObjFunc>;  // { func: boolean | undefined ; func1: boolean | undefined }

    // é”®å€¼é‡æ˜ å°„
    type Person = {
      age: number;
      name: string;
    }

    type GetPersonInfo<T> = {
      [key in keyof T as `get${Capitalize<string & key>}`] : () => T[key];
    }
    // { getAge: () => number; getName: () => string };
    type Res = GetPersonInfo<Person>; 

    // å»é™¤æŸå±æ€§
    type Person = {
      age: number;
      name: string;
    }

    type removePersonAge<T> = {
      [key in keyof T as Exclude<key, 'age'>] : T[key];
    }
    // { name: string };
    type Res = removePersonAge<Person>; 

    // key æ›¿æ¢ï¼Œé‡æ–°ç”Ÿæˆå¯¹è±¡

    type SquareEvent = { type: "square", x: number, y: number };
    type CircleEvent = { type: "circle", radius: number };
    type EventConfig<Es extends { type: string}> = {
      [E in Es as E['type']]: (event: E) => void;
    }

    // { square: (event: SquareEvent) }
    type Config = EventConfig<SquareEvent | CircleEvent>

    // æ ¹æ®valueå€¼ç”Ÿæˆä½œä¸ºæ¡ä»¶æ˜ å°„å‡ºæ–°çš„å€¼
    type Obj = {  a: { age: number; name: string};  b: { age: number; gender: "M" }};

    type DBFilter<T> = {
      [key in keyof T]: T[key] extends { gender: string } ? true : false;
    }
    // { a: false; b: true }
    type hasGender = DBFilter<Obj>

  ```
- æ€»ç»“
  <br> tips: as é‡æ˜ å°„æ—¶å€™ï¼Œas å¯ä»¥ç†è§£ä¸º <=> åº”è¯¥è½¬åŒ–æˆè¿™æ ·ï¼Œé‡æ–°filterä¹Ÿå¯¹ã€‚
  


## Template æ¨¡ç‰ˆè¯­æ³•

- ä¾‹å­
  ```typescript
    // å˜é‡
    type World = 'world';
    type Helloworld = `hello ${World}`; // hello world;

    // è”åˆç±»å‹åˆ†é…
    type Adjective = 'å¾ˆ' | 'éå¸¸';
    type badAdjective = 'å¾ˆä¸' | 'éå¸¸ä¸';
    type sumString = `${Adjective | badAdjective}ğŸ®`; // type sumString = "å¾ˆğŸ®" | "éå¸¸ğŸ®" | "å¾ˆä¸ğŸ®" | "éå¸¸ä¸ğŸ®"

    const obj = { index: 1, func: () => {}, sym: Symbol() };
    type Obj = typeof obj;  // { index: number; func: () => void; sym: symbol }

    const arr = [1,2,3,4];
    type Arr = typeof arr;  // number[]
  ```
- æ€»ç»“
  <br> tips: å¯ä»¥çœ‹ä½œå–å±æ€§çš„ç±»å‹å£°æ˜

## Generics èŒƒå‹

- ä¾‹å­
  ```typescript
    // å˜é‡
    function identity<Type>(arg: Type): Type {
      // console.log(arg.lenght);  // fail
      return arg;
    }
    let outPut = identity('string');
    
    // ç±»å‹çº¦æŸ
    // ä¸Šé¢è¯´äº†ï¼Œå¦‚æœä¸æŒ‡å®šä¼šè®¤ä¸ºä»£è¡¨æ‰€æœ‰ç±»å‹ï¼Œè®¤ä¸ºæ­¤å‡½æ•°æœ‰å¯èƒ½æ˜¯ä¸ªå­—ç¬¦ä¸²ã€‚å¦‚æœæˆ‘ä»¬éœ€æ±‚æ˜¯è®©æˆ‘ä»¬ä¼ é€’ä¸€ä¸ªæ•°ç»„ï¼Œè¿™é‡Œå°±å¯ä»¥ä½¿ç”¨èŒƒæ€§æ•°ç»„ï¼Œä»è€Œè¾¾åˆ°ä¸€ä¸ªæ³›å‹é¢„çº¦çš„æ•ˆæœ

    function identity<Type>(arg: Type[]): Type[] {
      // console.log(arg.lenght);  // succese
      return arg;
    }
    let outPut = identity([1]);

    // å¦‚æœæˆ‘ä»¬å°±æƒ³çº¦æŸå®ƒæœ‰ä¸ªlengthå±æ€§
    // è¿™é‡Œç­‰åŒäº[Type] or Array<Type>
    
    function identity<Type extends { length: number }>(arg: Type): Type { 
      // console.log(arg.lenght);  succese
      return arg;
    }
    let outPut = identity({ length: 3 });
    let outPut = identity('123');
    let outPut = identity([1,2]);

    // å‚æ•°çº¦æŸ
    function identify<Obj, Key keyof Obj>(obj: Obj, key: Key) {
      return obj[key];
    }
    let outPut = identity({name: 'è€ç‹', age: 18}, 'age');

    // class
    // new () => Animate === { new () : Animate }

    function createInstance<Animate>(animate: new () => Animate): Animate {
      return animate();
    }

  ```
- æ€»ç»“
  <br> tips: èŒƒæ€§å°±æ˜¯ä¸€ä¸ªå±•ä½çš„ç±»å‹ï¼Œè¡¨ç¤ºæ‰€æœ‰çš„å¯èƒ½çš„ç±»å‹, ä½†æ˜¯åˆæ›´anyç±»å‹ä¸ä¸€è‡´ã€‚ è¿è¡Œæ—¶ä¼šè§£æå‡ºä¸€ä¸ªå®é™…çš„ç±»å‹ã€‚æ³›å‹é¢„çº¦å°±æ˜¯æ”¶çª„è¿™ä¸ªå¯èƒ½çš„ç±»å‹æœç€ä½ è‡ªå·±çš„éœ€æ±‚çš„ç±»å‹èµ°å»ã€‚
  
- 